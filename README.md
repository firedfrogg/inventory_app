# Tugas 7
#####  Apa perbedaan utama antara *stateless* dan *stateful widget* dalam konteks pengembangan aplikasi Flutter?
- Perbedaan utama antara `StatelessWidget` dan `StatefulWidget` dalam pengembangan aplikasi Flutter terletak pada pengelolaan keadaan atau **state**. `StatelessWidget` adalah tipe *widget* yang tidak memiliki keadaan internal yang dapat berubah selama siklus hidup widget. Dalam konteks ini, mereka digunakan untuk membangun komponen tampilan yang statis, artinya tampilan tersebut tidak perlu merespon terhadap perubahan data atau *input*. Contohnya, sebuah widget yang menampilkan teks atau ikon statis akan ideal sebagai `StatelessWidget` karena tampilannya tidak berubah seiring waktu.

- Di sisi lain, `StatefulWidget` adalah tipe *widget* yang dapat memiliki keadaan internal yang dapat berubah. Mereka dirancang untuk mengakomodasi tampilan yang perlu merespon dengan data dinamis atau *input* pengguna. Ketika data atau *input* berubah, `StatefulWidget` dapat memperbarui tampilan sesuai dengan perubahan tersebut. Contoh penggunaan `StatefulWidget` adalah dalam pembuatan formulir, daftar yang dapat di-*scroll*, atau tampilan yang bergantung pada perubahan data, contohnya adalah jumlah pesanan. Dengan `StatefulWidget`, kita dapat menjaga dan memperbarui *state* atau keadaan internal widget sesuai dengan perkembangan dalam aplikasi, yang menjadikannya fleksibel untuk menciptakan tampilan yang responsif dan dinamis.

#####  Sebutkan seluruh widget yang kamu gunakan untuk menyelesaikan tugas ini dan jelaskan fungsinya masing-masing.
- `MyApp` adalah *root widget* dari aplikasi. Ini bertanggung jawab untuk mengatur tema dan judul aplikasi. Dalam contoh ini, tema aplikasi disesuaikan dengan warna indigo, dan judul aplikasi diatur sebagai "Inventory App" `MyApp` juga merupakan tempat dimulainya seluruh aplikasi Flutter.

- `MyHomePage` adalah *widget* yang memunculkan tampilan beranda aplikasi. Di dalamnya, pengguna akan melihat judul "Inventory App" yang terletak di bagian atas, dan di bawahnya, daftar tombol yang dapat ditekan. Tombol-tombol ini dihasilkan menggunakan `GridView`, sehingga tampilan beranda rapi dan terorganisir. `MyHomePage` berperan sebagai tampilan utama yang memuataftar tombol.

- `ShopCard` adalah widget kustom yang digunakan untuk membuat kartu yang menampilkan ikon dan teks untuk setiap tombol dalam daftar. `ShopCard` digunakan untuk mengatur tampilan dan perilaku setiap item di Inventory App secara terpisah. Selain itu, `ShopCard` juga berfungsi untuk menentukan warna latar belakang kartu berdasarkan nama item, sehingga tombol-tombol memiliki tampilan yang berbeda-beda (di sini, saya menampilkan warna merah, hijau, dan biru pada masing-masing `ShopCard`).

##### Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step (bukan hanya sekadar mengikuti tutorial)
- Implementasi checklist tugas ini dimulai dengan pembuatan aplikasi Flutter dengan perintah `flutter create inventory_app`. Langkah pertama adalah menggunakan widget `MyApp` sebagai *root widget* untuk mengonfigurasi tema dan judul aplikasi. Dalam hal ini, tema aplikasi diatur dengan warna indigo, dan judul "Inventory App" ditetapkan sebagai judul aplikasi. Selanjutnya, dalam *widget* `MyHomePage`, daftar item-item dalam aplikasi Invetory App yang direpresentasikan oleh model `ShopItem` didefinisikan dalam sebuah `list`. Model `ShopItem` ini memuat dua informasi, yaitu nama item dan ikon yang akan ditampilkan pada masing-masing tombol.

- *Widget* `GridView` digunakan dalam tampilan beranda `MyHomePage` untuk menampilkan setiap item toko sebagai `ShopCard`. Setiap `ShopCard` adalah *widget* yang berfungsi untuk membuat kartu dengan menampilkan ikon dan teks untuk masing-masing tombol. Selain itu, `ShopCard` juga mengatur warna *background* kartu berdasarkan nama item yang bersesuaian. Ini menciptakan tampilan yang berbeda-beda untuk setiap tombol, sesuai dengan *requirement* bonus untuk tugas ini.

- Ketika pengguna menekan salah satu kartu, metode `_showSnackBar` di dalam `ShopCard` dipanggil, menghasilkan pesan `Snackbar` sesuai dengan tombol yang ditekan. Contohnya, jika tombol "Lihat Item" ditekan, pesan `Snackbar` akan menampilkan informasi "Kamu telah menekan tombol Lihat Item."

# Tugas 8
#####  Jelaskan perbedaan antara Navigator.push() dan Navigator.pushReplacement(), disertai dengan contoh mengenai penggunaan kedua metode tersebut yang tepat!
- `Navigator.push()` dan `Navigator.pushReplacement()` adalah dua metode dalam Flutter yang digunakan untuk navigasi antar halaman dalam sebuah aplikasi. `Navigator.push()` digunakan untuk menambahkan rute baru ke *navigator*, yang memungkinkan pengguna untuk kembali ke halaman sebelumnya. Sebagai contoh, jika sebuah user berada di halaman beranda dan menggunakan `Navigator.push()` untuk berpindah ke halaman detail, pengguna bisa kembali ke halaman beranda dengan tombol kembali. Sebaliknya, `Navigator.pushReplacement()` menggantikan rute aplikasi saat ini dengan rute baru di dalam navigator sehingga pengguna tidak dapat kembali ke halaman sebelumnya. Misalnya, dalam aplikasi *login*, setelah berhasil masuk, `Navigator.pushReplacement()` dapat digunakan untuk berpindah dari halaman *login* ke halaman beranda, mencegah pengguna kembali ke halaman *login*.

#####  Jelaskan masing-masing layout widget pada Flutter dan konteks penggunaannya masing-masing!
- Flutter memiliki berbagai jenis layout widget yang memungkinkan pengaturan *layout* elemen-elemen dengan fleksibel dan presisi. Pertama, `Container` adalah *widget* yang digunakan untuk mengelompokkan, mengatur, dan menghias elemen-elemen dalam satu kotak. Ini berguna untuk membuat kotak sekitar `widget` lain, dan dapat digabungkan dengan banyak *property* lain seperti `margin`, `padding`, dan `decoration`. Kedua, `Row` dan `Column` adalah `widget` yang digunakan untuk mengatur elemen-elemen dalam baris atau kolom secara berurutan. Mereka berguna untuk tata letak dan sangat berguna dalam membuat tampilan seperti daftar atau navigasi. Ketiga, `Stack` adalah `widget` yang memungkinkan penempatan elemen-elemen di atas satu sama lain dengan bebas, cocok untuk tata letak yang kompleks seperti tumpukan kartu. Keempat, `ListView` adalah widget yang berguna untuk membuat daftar gulir yang bisa diisi dengan banyak elemen, baik vertikal maupun horizontal. Terakhir, `Expanded` adalah widget yang digunakan dalam `Row` atau `Column` untuk memberikan ruang tambahan kepada elemen-elemen dalam tata letak fleksibel seperti tata letak tumpukan berbobot. Dengan pemahaman yang baik tentang penggunaan masing-masing `layout` `widget` ini, user dapat membuat antarmuka pengguna Flutter yang responsif dan menarik.

#####  Sebutkan apa saja elemen input pada form yang kamu pakai pada tugas kali ini dan jelaskan mengapa kamu menggunakan elemen input tersebut!
- `TextFormField` untuk Nama: `TextFormField` digunakan untuk mengumpulkan nama pengguna. Penggunaan `TextFormField` memungkinkan validasi nama, seperti memastikan nama tidak kosong dan hanya mengandung karakter alfabet. Ini membantu memastikan bahwa data yang dimasukkan sesuai dengan format yang diharapkan.

- `TextFormField` untuk Jumlah Barang: `TextFormField` juga digunakan untuk mengumpulkan informasi tentang jumlah barang yang ingin ditambahkan. Ini penting karena kita perlu tahu berapa banyak barang yang ingin dimasukkan pengguna. Dengan menggunakan `TextFormField`, kita dapat memastikan bahwa pengguna hanya memasukkan angka, dan kita dapat menerapkan validasi untuk memastikan bahwa angka yang dimasukkan adalah positif dan bukan nol.

- `TextFormField` untuk Deskripsi Barang: `TextFormField` digunakan untuk mengumpulkan deskripsi barang yang ingin ditambahkan oleh pengguna. Dengan menggunakan TextFormField, pengguna dapat memasukkan teks deskripsi dengan format `String`, dan kita dapat menerapkan validasi untuk memastikan bahwa deskripsi tersebut tidak kosong.

#####  Bagaimana penerapan clean architecture pada aplikasi Flutter?
- Penerapan *clean architecture* pada aplikasi Flutter melibatkan organisasi kode menjadi beberapa lapisan yang terpisah untuk meningkatkan pemisahan tanggung jawab dan *maintainability*. Pertama, ada lapisan `Presentation` yang mencakup tampilan antarmuka dan logika terkait UI tersebut. Lapisan ini dapat diimplementasikan menggunakan widget Flutter seperti `StatelessWidget` dan `StatefulWidget`. Selanjutnya, terdapat lapisan `Domain`, yang berisi aturan inti dan entitas aplikasi. Lapisan ini tidak bergantung pada detail implementasi dan dapat diuji secara terpisah. Terakhir, ada lapisan `Data` yang mengelola akses ke sumber data eksternal seperti API atau *database*. Penerapan clean architecture di Flutter memastikan bahwa kode di setiap lapisan adalah independen dan mudah diuji, memungkinkan pengembangan yang lebih skalabel, mudah dipelihara, dan mematuhi prinsip-prinsip desain yang baik.

##### Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step! (bukan hanya sekadar mengikuti tutorial)
- Untuk mengembangkan halaman tambah item baru dalam aplikasi Flutter, saya pertama-tama membuat kelas `ItemFormPage` yang akan menjadi halaman formulir. Saya memastikan kelas ini bersifat *stateful* untuk mengelola perubahan dalam formulir. Kemudian, saya membuat kelas `_ItemFormPageState` yang digunakan untuk mengelola state internal dari halaman formulir. Di dalam method `build` dari `_ItemFormPageState`, saya menggunakan widget `Scaffold` untuk membuat kerangka dari formulir. Di dalam `Scaffold`, saya menggunakan objek `Form` untuk mengelola formulir dengan validasi. Tiga elemen input, yaitu `name`, `amount`, dan `description` dikelompokkan menggunakan `TextFormField`.

- Untuk tombol `Save` saya menggunakan objek `ElevatedButton` yang akan menyimpan data formulir saat ditekan. Validasi dilakukan oleh atribut `key` dari `Form` yang telah diinisialisasi sebagai `GlobalKey<FormState>()`. Setiap elemen input di formulir juga divalidasi untuk memastikan mereka tidak boleh kosong dan harus memiliki tipe data yang sesuai dengan atribut modelnya.

- Ketika pengguna menekan tombol `Tambah Item` pada halaman utama, saya menggunakan `Navigator.push` untuk mengarahkannya ke halaman `form` menggunakan kelas `ItemFormPage`. Setelah pengguna mengisi formulir dan menekan tombol `Save` data yang dimasukkan akan muncul dalam sebuah pop-up menggunakan `showDialog`, sehingga pengguna dapat melihat data yang telah mereka tambahkan.

- Untuk drawer aplikasi, saya membuat kelas `LeftDrawer` yang berisi elemen-elemen `drawer`. Di dalamnya, saya menggunakan `ListView` untuk membuat isi `drawer`. `Drawer` memiliki dua opsi, yaitu `Halaman Utama` dan `Tambah Item` Saat pengguna memilih `Halaman Utama` aplikasi akan mengarahkannya kembali ke halaman utama menggunakan `Navigator.pushReplacement()`. Ketika pengguna memilih `Tambah Item` aplikasi akan mengarahkan pengguna ke halaman form tambah item baru dengan menggunakan `Navigator.pushReplacement()`. Dengan demikian, pengguna dapat dengan mudah menambahkan item baru ke dalam aplikasi dan melihatnya dalam `pop-up` setelah menyimpan data tersebut.



# Tugas 9
##### Apakah bisa kita melakukan pengambilan data JSON tanpa membuat model terlebih dahulu? Jika iya, apakah hal tersebut lebih baik daripada membuat model sebelum melakukan pengambilan data JSON?
- Kita dapat melakukan pengambilan data JSON tanpa membuat model terlebih dahulu dalam Flutter. Kita bisa menggunakan `dart:convert` untuk mengubah respons `HTTP` yang berformat `JSON` menjadi `Map`. Dengan pendekatan ini, kita tidak perlu mendefinisikan kelas model terlebih dahulu. Kita bisa langsung mengakses data yang diperlukan melalui Map. Namun, pendekatan ini memiliki kelemahan. Tanpa model, kode kita menjadi kurang terstruktur dan lebih sulit untuk dipahami dan dikelola. Kita juga kehilangan manfaat dari fitur-fitur Dart seperti type checking dan autocompletion. Oleh karena itu, pendekatan ini biasanya hanya digunakan untuk proyek-proyek kecil atau untuk prototyping cepat. Untuk proyek yang lebih besar dan kompleks, biasanya lebih baik untuk mendefinisikan model terlebih dahulu. Model membantu kita untuk memahami struktur data kita dan membuat kode kita lebih mudah untuk dibaca dan dikelola. Dengan demikian, meskipun pendekatan tanpa model ini dapat digunakan dalam beberapa kasus, pendekatan dengan model biasanya lebih disukai untuk proyek yang lebih besar dan kompleks.
##### Jelaskan fungsi dari `CookieRequest` dan jelaskan mengapa instance CookieRequest perlu untuk dibagikan ke semua komponen di aplikasi Flutter.
- Dalam konteks umum pengembangan web dan aplikasi, `CookieRequest` bisa merujuk pada permintaan HTTP yang mencakup *cookie* dalam *header*-nya. *Cookie* adalah potongan data kecil yang disimpan di perangkat pengguna dan dikirim kembali ke server dengan setiap permintaan berikutnya. *Cookie-cookie* tersebut biasanya digunakan untuk melacak sesi pengguna, menyimpan preferensi pengguna, dan melakukan autentikasi pengguna. Dalam konteks aplikasi Flutter, *cookie* dapat digunakan untuk berbagai tujuan, seperti autentikasi pengguna, pelacakan sesi, dan penyimpanan preferensi pengguna. Misalnya, ketika pengguna masuk ke aplikasi, server dapat mengirimkan *cookie* yang berisi token untuk autentikasi pengguna. Kemudian, aplikasi dapat menyimpan *cookie* ini dan mengirimkannya kembali ke *server* dengan setiap permintaan berikutnya sehingga *server* tahu bahwa permintaan tersebut berasal dari pengguna yang telah diuatentikasi. Oleh karena itu, sangat penting untuk membagikan instance CookieRequest (atau objek yang serupa) ke semua komponen dalam aplikasi Flutter. Dengan cara ini, semua komponen dapat mengakses dan menggunakan *cookie* yang sama dan memastikan bahwa *cookie-cookie* tersebut berinteraksi seluruhnya dengan server sebagai pengguna yang sama.
##### Jelaskan mekanisme pengambilan data dari JSON hingga dapat ditampilkan pada Flutter.
- Dalam Flutter, pengambilan data dari JSON hingga dapat ditampilkan melibatkan beberapa langkah. Pertama, data JSON tersebut perlu diambil sendiri. Pengambilan data JSON tersebut biasanya dilakukan dengan mengirim permintaan HTTP ke *server* menggunakan *package* seperti HTTP. Setelah mendapatkan respons HTTP, kita perlu mengubah respons tersebut yang sebelumnya merupakan tipe data JSON menjadi struktur data Dart yang dapat kita gunakan dalam kode kita. Ini biasanya dilakukan dengan menggunakan fungsi `jsonDecode` dari pustaka `dart:convert`. Setelah data telah diubah menjadi struktur data Dart (biasanya tipe data setelah diubah adalah Map atau List), kita dapat menggunakan data tersebut dalam aplikasi yang sudah dibuat. Misalnya, kita mungkin ingin menampilkan data dalam `ListView` atau *widget* serupa. Biasanya, kita  akan menggunakan `FutureBuilder` atau `StreamBuilder` untuk membuat *widget* yang dapat menangani data-data secara asinkron. Dengan cara ini, kita dapat memastikan bahwa aplikasi kita tetap responsif sementara kita menunggu data dari server.
##### Jelaskan mekanisme autentikasi dari input data akun pada Flutter ke Django hingga selesainya proses autentikasi oleh Django dan tampilnya menu pada Flutter.
- Proses autentikasi dalam aplikasi Flutter yang menggunakan *backend* Django meliputi beberapa langkah. Pertama-tama, pengguna akan diminta untuk memasukkan data akun mereka, seperti nama pengguna dan kata sandi, melalui antarmuka *login* di aplikasi Flutter. Setelah pengguna memasukkan data ini, aplikasi Flutter kemudian akan mengirimkan data ini ke *server* Django. Pengiriman data ini biasanya dilakukan dengan membuat permintaan HTTP `POST` ke *endpoint* autentikasi di server Django dengan data akun pengguna disertakan dalam badan permintaan. Setelah server Django menerima permintaan ini, server Django akan memproses data yang diterima. Pemrosesan data oleh Djnago biasanya dilakukan dengan membandingkan nama pengguna dan kata sandi yang diterima dengan data yang disimpan di *database*. Jika data akun yang diterima cocok dengan data yang disimpan di *database*, maka *server* akan menganggap bahwa pengguna telah berhasil diautentikasi. Sebagai respons atas permintaan autentikasi yang berhasil, server Django kemudian akan menghasilkan token autentikasi dan mengirimkannya kembali ke aplikasi Flutter dalam respons HTTP. Aplikasi Flutter kemudian dapat menyimpan token ini dan menggunakannya untuk permintaan berikutnya ke *server* sehingga server dapat mengenali pengguna dan melakukan verifikasi kepada mereka telah diautentikasi. Setelah proses autentikasi selesai, aplikasi Flutter kemudian dapat menampilkan menu kepada pengguna, memungkinkan mereka untuk berinteraksi dengan bagian-bagian lain dari aplikasi.

##### Sebutkan seluruh widget yang kamu pakai pada tugas ini dan jelaskan fungsinya masing-masing.
- `Scaffold` adalah *widget* utama yang digunakan untuk membangun aplikasi Flutter. Scaffold menyediakan struktur dasar aplikasi, termasuk app bar, `drawer`, dan `body` content, `AppBar` adalah widget yang menyediakan bar judul di bagian atas layar. `AppBar` juga dapat berisi tombol, ikon, dan *widget* lainnya. `LeftDrawer` adalah *widget* drawer yang muncul dari sisi kiri layar. `Drawer` dapat digunakan untuk bernavigasi ke bagian-bagian berbeda dalam aplikasi. `Form` adalah *widget* yang digunakan untuk mengelompokkan *widget-widget* yang terkait dengan `Form`. `Form` menyediakan validasi *input* untuk field formulir. `SingleChildScrollView` adalah *widget* yang memungkinkan *widget* anak untuk menggulir secara vertikal jika kontennya melebihi ruang yang tersedia. *Column* adalah widget yang mengatur widget-widget `Child` secara vertikal. `Align` adalah widget yang mengatur posisi widget anak dalam batas-batasnya. Dalam kasus ini, `Align` digunakan untuk menempatkan tombol "Simpan" secara horizontal di tengah. `Padding` adalah widget yang menambahkan ruang kosong di sekitar widget `Child`. `ElevatedButton` adalah *widget* tombol terangkat yang umum digunakan untuk mengirimkan formulir. `TextFormField` adalah *widget* field input teks. `TextFormField` memungkinkan pengguna untuk memasukkan teks dan menyediakan validasi dan penanganan kesalahan. `InputDecoration` adalah *widget* yang mendefinisikan tampilan visual `TextFormField`. `OutlineInputBorder` adalah jenis border yang menggambar garis luar di sekitar `TextFormField`. `BorderRadius` adalah widget yang mendefinisikan sudut membulat dari OutlineInputBorder.

##### Jelaskan bagaimana cara kamu mengimplementasikan checklist di atas secara step-by-step! (bukan hanya sekadar mengikuti tutorial).
- Pertama-tama, saya melakukan setup autentikasi pada Django untuk Flutter. Saya melakuannya dengan membuat *app* baru dan melakukan setting terhadap `settings.py` untuk keperluan autentikasi. Lalu saya mengisi *method* `views.py` untuk *login* dan *logout* pada aplikasi lalu menghubungkannya dengan projek melalui `urls.py`. Setelahnya, saya melakukan integrasi sistem autentikasi pada Flutter dengan meng-instal *package* yang telah disediakan oleh tim asisten dosen dan memodifikasi *root widget* untuk menyediakan `CookieRequest` *library* ke semua *child widgets* dengan menggunakan `Provider`. Lalu, saya membuat file baru `login.dart` dan mengisi fungsionalitas *login* pada file baru tersebut.

- Setelah itu, saya membuat model kustom pada `Quicktype` lalu mengkopi kode yang ada pada `Quicktype` dan menyimpannya pada *file* baru `product.dart` yang baru dibuat pada folder `lib/models`. Lalu, saya menlakukan penerapan *fetch* data dari Django untuk ditampilkan ke Flutter dengan menambahkan dependensi HTTP dengan menamabhkan package `http` dan menambahkan kode pada `android/app/src/main/AndroidManifest.xml`. Pada folder `list_product.dart`, saya mengimpor library-library yang dibutuhkan, dan menambah kode untuk melakukan *fetch* terhadap *product* yang dibuat, seperti *decode response* menjadi bentuk JSON dan mengubah JSON tersebut menjadi objek `Product`. Setelah itu, saya menambahkan bagian `Daftar Produk` pada `left_drawer.dart` sekaligus menambahkan fungsionalitasnya.

- Di Django, saya membuat *method* baru pada `main/views.py` yang digunakan untuk membuat produk di dalam aplikasi dengan menggunakan Flutter yang bernama `create_product_flutter` dan menghubungkan method tersebut ke dalam `urls.py`. Lalu, saya menghubungkan halaman `shoplist_form.dart` dengan `CookieRequest`, mengubah perintah `onPresseD: ()` dengan menambahkan `async` pada method tersebut, dan melakukan sedikit *quick fix* untuk mengimpor *file-file* yang dibutuhkan. Terakhir, saya menambahkan fungsionalitas *logout* pada aplikasi Django dengan menambahkan method baru ke dalam `authentication/views.py`, menghubungkannya ke `urls.py`, menghubungkannya dengan `shop_card.dart`, menambahkan `CookieRequest` pada `shop_card.dart`, dan menambahkan `async` pada widget Inkwell pada perintah `onTap: ()`menjadi `ontap: () async {...}`. Setelah itu, saya melakukan `add`, `commit`, dan `push` untuk memperbarui repositori GitHub